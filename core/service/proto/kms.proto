syntax = "proto3";
package kms;

// TODO seperate into threshold and central calls
service CoreServiceEndpoint {
  // Perform the threshold KMS initialization.
  // This call returns an error on the centralized KMS.
  rpc Init(InitRequest) returns (Empty);

  // Start generating preprocessing materials for key generation asynchronously.
  // This call returns an error on the centralized KMS.
  rpc KeyGenPreproc(KeyGenPreprocRequest) returns (Empty);

  // This call returns an error on the centralized KMS.
  rpc GetPreprocStatus(RequestId) returns (KeyGenPreprocStatus);

  // Generate new keys asynchronously.
  rpc KeyGen(KeyGenRequest) returns (Empty);

  // Return a URI where they can be accessed.
  // The keys at the URI contains signature and authentication information.
  // NOTE: Unprivileged and insecure call
  rpc GetKeyGenResult(RequestId) returns (KeyGenResult);

  // Decrypt a ciphertext and return the signed plaintext.
  rpc Decrypt(DecryptionRequest) returns (Empty);

  // Get the decryption result.
  // This query fails if the result is not available yet.
  rpc GetDecryptResult(RequestId) returns (DecryptionResponse);

  // Reencrypt a ciphertext under a user-specified key and return a signcrypted
  // share of the dercrypted plaintext.
  rpc Reencrypt(ReencryptionRequest) returns (Empty);

  // Get the reencryption result.
  // This query fails if the result is not available yet.
  rpc GetReencryptResult(RequestId) returns (ReencryptionResponse);

  // Start the CRS generatioin protocol asynchronously.
  rpc CrsGen(CrsGenRequest) returns (Empty);

  // Get a reference to the CRS.
  // This query fails if the result is not available yet.
  rpc GetCrsGenResult(RequestId) returns (CrsGenResult);

  // Start a zero-knowledge proof verification
  // on a ProvenCompactCiphertextList.
  rpc ZkVerify(ZkVerifyRequest) returns (Empty);

  // Get the zero-knowledge verification result.
  rpc GetZkVerifyResult(RequestId) returns (ZkVerifyResponse);
}

// Initialization request for bootstrapping the threshold KMS.
message InitRequest {
  // Eventually the config will contain role assignment,
  // this is needed for the threshold protocol.
  Config config = 1;
}

// Placeholder response, when no content is needed
message Empty {}

// Simple response to return an ID, to be used to retrieve the computed result
// later on.
message RequestId { string request_id = 1; }

// Status for Keygen Preproc
enum KeyGenPreprocStatusEnum {
  Missing = 0;
  InProgress = 1;
  Finished = 2;
  Error = 3;
  WrongRequest = 4;
}

// The plaintext types that can be encrypted in a fhevm ciphertext.
enum FheType {
  Ebool = 0;
  Euint4 = 1;
  Euint8 = 2;
  Euint16 = 3;
  Euint32 = 4;
  Euint64 = 5;
  Euint128 = 6;
  Euint160 = 7;
  Euint256 = 8;
  Euint512 = 9;
  Euint1024 = 10;
  Euint2048 = 11;
}

message KeyGenPreprocRequest {
  Config config = 1;
  ParamChoice params = 2;
  RequestId request_id = 3;
}

message KeyGenPreprocStatus { KeyGenPreprocStatusEnum result = 1; }

// Request for generating new keys under a certain handle and return a URI where
// they can be accessed.
message KeyGenRequest {
  Config config = 1;
  ParamChoice params = 2;
  RequestId preproc_id = 3;
  RequestId request_id = 4;
}

message Config {
  // TODO placeholder
}

message KeyGenResult {
  // The ID of the key generation request
  RequestId request_id = 1;
  map<string, SignedPubDataHandle> key_results = 2;
}

// The result of generation of a public key
message SignedPubDataHandle {
  // The key handle; hash digest of the key bytes
  string key_handle = 1;
  // Signature on the key handle
  bytes signature = 2;
}

// Keeping the fields in lowercase is important because
// it needs to match what the config reads out of the toml config files,
// e.g., in default_centralized.toml.
enum ParamChoice {
  test = 0;
  default = 1;
}

message CrsGenRequest {
  Config config = 1;
  ParamChoice params = 2;
  // This is the maximum number of bits that can be proven,
  // e.g. 64 for a single FheUint64 or 8 x FheUint8 values.
  // If this is not provided, then it defaults to ZK_DEFAULT_MAX_NUM_CLEARTEXT.
  optional uint32 max_num_bits = 3;
  RequestId request_id = 4;
}

message CrsGenResult {
  // The ID of the crs generation request
  RequestId request_id = 1;
  // The struct holding the signature and the handle of the CRS
  SignedPubDataHandle crs_results = 2;
}

message TypedCiphertext {
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  bytes ciphertext = 1;
  // The type of plaintext encrypted.
  FheType fhe_type = 2;
  // The external handle of the ciphertext (the handle used in the fhevm).
  optional bytes external_handle = 3;
}

message DecryptionRequest {
  // Version of the request format.
  uint32 version = 1;
  // The one or many ciphertexts and corresponding types to decrypt
  repeated TypedCiphertext ciphertexts = 2;
  // The key id to use for decryption, will be the request_id used for key
  // generation
  RequestId key_id = 3;
  // The ID of the decryption request. Will be the hash digest the other fields
  // of this message object.
  RequestId request_id = 4;
}

// KMS-internal Decryption Response Payload, containing meta data, plaintexts
// and external results
message DecryptionResponsePayload {
  // Version of the response format.
  uint32 version = 1;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  // TODO should be renamed to make it clear it is the server's key
  bytes verification_key = 2;

  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 3;
  // A list of plaintexts, as little endian byte arrays. One for each
  // ciphertext.
  repeated bytes plaintexts = 4;
  // the signature on external_decryption_result for the external recipient
  // (e.g. the fhevm)
  optional bytes external_signature = 6;
}

// KMS-internal Decryption Response
message DecryptionResponse {
  // Signature of the serialization of [DecryptionResponsePayload].
  bytes signature = 1;
  // The payload that is signed
  DecryptionResponsePayload payload = 2;
}

message ReencryptionRequestPayload {
  // Version of the request format.
  uint32 version = 1;
  // The client's (blockchain wallet) address,
  // encoded using EIP-55.
  string client_address = 2;
  // Encoding of the user's public encryption key for this request.
  // Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
  // Montgomery point.
  bytes enc_key = 3;
  // The type of plaintext encrypted.
  FheType fhe_type = 4;
  // The key id to use for decryption. Will be the request_id used during key
  // generation
  RequestId key_id = 5;
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  // When creating the payload, this field may be empty,
  // it is the responsibility of the gateway to fetch the
  // ciphertext for the given digest below.
  optional bytes ciphertext = 6;
  // The SHA3 digest of the ciphertext above.
  bytes ciphertext_digest = 7;
}

// https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator
// eventually chain_id, verifying_contract and salt will be parsed in to
// solidity types
message Eip712DomainMsg {
  string name = 1;
  string version = 2;
  bytes chain_id = 3;
  string verifying_contract = 4;
  bytes salt = 5;
}

message ReencryptionRequest {
  // Signature of the serialization of [ReencryptionRequestPayload].
  bytes signature = 1;
  ReencryptionRequestPayload payload = 2;
  Eip712DomainMsg domain = 3;
  // The ID that identifies this request.
  // Future queries for the result must use this request ID.
  RequestId request_id = 4;
}

message ReencryptionResponse {
  bytes signature = 1;
  // Signature of the serialization of [ReencryptionResponsePayload].
  ReencryptionResponsePayload payload = 2;
}

message ReencryptionResponsePayload {
  // Version of the response format.
  uint32 version = 1;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  bytes verification_key = 2;
  // The concatenation of two digests:
  // (eip712_signing_hash(pk, domain) || ciphertext digest).
  // This is needed to ensure the response corresponds to the request.
  bytes digest = 3;
  // The type of plaintext encrypted.
  FheType fhe_type = 4;
  // The signcrypted payload, using a hybrid encryption approach in
  // sign-then-encrypt.
  bytes signcrypted_ciphertext = 5;
  // The ID of the MPC party doing the reencryption. Used for polynomial
  // reconstruction.
  uint32 party_id = 6;
  // The degree of the sharing scheme used.
  uint32 degree = 7;
}

message ZkVerifyRequest {
  RequestId crs_handle = 1;
  RequestId key_handle = 2;
  string contract_address = 3;
  string client_address = 4;
  bytes ct_bytes = 5;
  RequestId request_id = 6;
}

message ZkVerifyResponse {
  ZkVerifyResponsePayload payload = 1;
  bytes signature = 2;
}

message ZkVerifyResponsePayload {
  RequestId request_id = 1;
  string contract_address = 2;
  string client_address = 3;
  bytes ct_digest = 4;
}