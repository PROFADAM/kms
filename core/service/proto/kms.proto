syntax = "proto3";
package kms;

// TODO seperate into threshold and central calls
service CoreServiceEndpoint {
  // Perform the threshold KMS initialization.
  // This call returns an error on the centralized KMS.
  rpc Init(InitRequest) returns (Empty);

  // Start generating preprocessing materials for key generation asynchronously.
  // This call returns an error on the centralized KMS.
  rpc KeyGenPreproc(KeyGenPreprocRequest) returns (Empty);

  // TODO to have common logic KeyGenPreprocRequest should only contain RequestId
  // This call returns an error on the centralized KMS.
  rpc GetPreprocStatus(KeyGenPreprocRequest) returns (KeyGenPreprocStatus);

  // Generate new keys asynchronously.
  rpc KeyGen(KeyGenRequest) returns (Empty);

  // Return a URI where they can be accessed.
  // The keys at the URI contains signature and authentication information.
  // NOTE: Unprivileged and insecure call
  rpc GetKeyGenResult(RequestId) returns (KeyGenResult);

  // Decrypt a ciphertext and return the signed plaintext.
  rpc Decrypt(DecryptionRequest) returns (Empty);

  // Get the decryption result.
  // This query fails if the result is not available yet.
  rpc GetDecryptResult(RequestId) returns (DecryptionResponse);

  // Reencrypt a ciphertext under a user-specified key and return a signcrypted share of the dercrypted plaintext.
  rpc Reencrypt(ReencryptionRequest) returns (Empty);

  // Get the reencryption result.
  // This query fails if the result is not available yet.
  rpc GetReencryptResult(RequestId) returns (ReencryptionResponse);

  // Start the CRS generatioin protocol asynchronously.
  rpc CrsGen(CrsGenRequest) returns (Empty);

  // Get a reference to the CRS.
  // This query fails if the result is not available yet.
  rpc GetCrsGenResult(RequestId) returns (CrsGenResult);
}

// Initialization request for bootstrapping the threshold KMS.
message InitRequest {
  Config config = 1;
  // Eventually the config will contain role assignment,
  // this is needed for the threshold protocol.
}

// Placeholder response, when no content is needed
message Empty {

}

// Simple response to return an ID, to be used to retrieve the computed result later on.
message RequestId {
  string request_id = 1;
}

//Status for Keygen Preproc
enum KeyGenPreprocStatusEnum {
  Missing = 0;
  InProgress = 1;
  Finished = 2;
  Error = 3;
  WrongRequest = 4;
}

// The plaintext types that can be encrypted in a fhevm ciphertext.
enum FheType {
  Bool = 0;
  Euint4 = 1;
  Euint8 = 2;
  Euint16 = 3;
  Euint32 = 4;
  Euint64 = 5;
  Euint128 = 6;
  Euint160 = 7;
  Euint256 = 8;
  Euint2048 = 9;
}

message KeyGenPreprocRequest {
  Config config = 1;
  ParamChoice params = 2;
  RequestId request_id = 3;
}

message KeyGenPreprocStatus {
  KeyGenPreprocStatusEnum result = 1;
}

// Request for generating new keys under a certain handle and return a URI where they can be accessed.
// TODO handle the potential need for randomness in the signed stored keys which may be needed to ensure provable EU-CMA security of ECDSA.
message KeyGenRequest {
  Config config = 1;
  ParamChoice params = 2;
  RequestId preproc_id = 3;
  RequestId request_id = 4;
}

message Config {
  // TODO placeholder
}

message KeyGenResult {
  // The ID of the key generation request
  RequestId request_id = 1;
  map<string, SignedPubDataHandle> key_results = 2;
}

// The result of generation of a public key
message SignedPubDataHandle {
  // The key handle; hash digest of the key bytes
  string key_handle = 1;
  // Signature on the key handle
  bytes signature = 2;
}

// Keeping the fields in lowercase is important because
// it needs to match what the config reads out of the toml config files,
// e.g., in default_centralized.toml.
enum ParamChoice {
  test = 0;
  default = 1;
}

message CrsGenRequest {
  Config config = 1;
  ParamChoice params = 2;
  RequestId request_id = 3;
}

message CrsGenResult {
  // The ID of the crs generation request
  RequestId request_id = 1;
  // The struct holding the signature and the handle of the CRS
  SignedPubDataHandle crs_results = 2;
}

message DecryptionRequest {
  // Version of the request format.
  uint32 version = 1;
  // The amount of responses needed to sure security of the result.
  // This implies the threshold used.
  // Needed to avoid a single malicious server taking over a request that should
  // have been distributed.
  uint32 servers_needed = 2;
  // Randomness added to the request.
  // Required to ensure formal EU-CMA security when using ECDSA.
  bytes randomness = 3;
  // The type of plaintext encrypted.
  FheType fhe_type = 4;
  // The key id to use for decryption, will be the request_id used for key generation
  RequestId key_id = 5;
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  bytes ciphertext = 6;
  // The ID of the decryption request. Will be the hash digest the other fields of this message object.
  RequestId request_id = 7;
}

message DecryptionResponsePayload {
  // Version of the response format.
  uint32 version = 1;
  // Servers_needed are not really needed since there is a link to the
  // digest, however, it seems better to be able to handle a response without
  // getting data from the request as well. but this is also a security issue
  // since it is possible to get meaning from the response without directly
  // linking it to a request
  //
  // The amount of responses needed to sure security of the result.
  // This implies the threshold used.
  uint32 servers_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  // TODO should be renamed to make it clear it is the server's key
  bytes verification_key = 3;
  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 4;
  // Randomness specified in the request to ensure EU-CMA of the signed
  // response.
  // TODO check that we don't need two types of randomness. One for the reuqest
  // and one for the response
  bytes plaintext = 5;
}

message DecryptionResponse {
  bytes signature = 1;
  // Signature of the ASN1 DER serialization of [DecryptionResponsePayload].
  DecryptionResponsePayload payload = 2;
}

message AggregatedDecryptionResponse {
  repeated DecryptionResponse responses = 1;
}

message ReencryptionRequestPayload {
  // Version of the request format.
  uint32 version = 1;
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  // Needed to avoid a single malicious server taking over a request that should
  // have been distributed.
  uint32 servers_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  // TODO not needed in the request! Should be removed
  bytes verification_key = 3;
  // Randomness specified in the request to ensure EU-CMA of the signed response.
  // TODO check that we don't need two types of randomness. One for the reuqest and one for the response
  // TODO also check potential risk with repeated calls
  bytes randomness = 4;
  // Encoding of the user's public encryption key for this request.
  // Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
  // Montgomery point.
  bytes enc_key = 5;
  // The type of plaintext encrypted.
  FheType fhe_type = 6;
  // The key id to use for decryption. Will be the request_id used during key generation
  RequestId key_id = 7;
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  // When creating the payload, this field may be empty,
  // it is the responsibility of the gateway to fetch the
  // ciphertext for the given digest below.
  optional bytes ciphertext = 8;
  // The SHA3 digest of the ciphertext above.
  bytes ciphertext_digest = 9;
}

// https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator
// eventually chain_id, verifying_contract and salt will be parsed in to solidity types
message Eip712DomainMsg {
  string name = 1;
  string version = 2;
  bytes chain_id = 3;
  string verifying_contract = 4;
  bytes salt = 5;
}

message ReencryptionRequest {
  // Signature of the ASN1 DER serialization of [ReencryptionRequestPayload].
  bytes signature = 1;
  ReencryptionRequestPayload payload = 2;
  Eip712DomainMsg domain = 3;
  // The ID that identifies this request.
  // Future queries for the result must use this request ID.
  RequestId request_id = 4;
}

message ReencryptionResponse {
  // Version of the response format.
  uint32 version = 1;
  // Servers_needed are not really needed since there is a link to the
  // digest, however, it seems better to be able to handle a response without
  // getting data from the request as well. but this is also a security issue
  // since it is possible to get meaning from the response without directly
  // linking it to a request
  //
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  uint32 servers_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  bytes verification_key = 3;
  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 4;
  // The type of plaintext encrypted.
  FheType fhe_type = 5;
  // The signcrypted payload, using a hybrid encryption approach in
  // sign-then-encrypt.
  bytes signcrypted_ciphertext = 6;
}

message AggregatedReencryptionResponse {
  map<uint32, ReencryptionResponse> responses = 1;
}
