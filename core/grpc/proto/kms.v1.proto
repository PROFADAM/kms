syntax = "proto3";
package kms.v1;

// Initialization request for bootstrapping the threshold KMS.
message InitRequest {
  // Eventually the config will contain role assignment,
  // this is needed for the threshold protocol.
  Config config = 1;
}

message Config {
  // TODO placeholder
}

// Placeholder response, when no content is needed
message Empty {}

// Simple response to return an ID, to be used to retrieve the computed result
// later on.
message RequestId { string request_id = 1; }

// Status for Keygen Preproc
enum KeyGenPreprocStatusEnum {
  Missing = 0;
  InProgress = 1;
  Finished = 2;
  Error = 3;
  WrongRequest = 4;
}

// The plaintext types that can be encrypted in a fhevm ciphertext.
enum FheType {
  Ebool = 0;
  Euint4 = 1;
  Euint8 = 2;
  Euint16 = 3;
  Euint32 = 4;
  Euint64 = 5;
  Euint128 = 6;
  Euint160 = 7;
  Euint256 = 8;
  Euint512 = 9;
  Euint1024 = 10;
  Euint2048 = 11;
}

// The type of keyset to generate during in a key generation call.
enum KeySetType {
  // The standard keyset usually consists of the computation key,
  // public key and compression/decompression keys, but it can be
  // configured further using StandardKeySetConfig.
  // This is the default variant.
  Standard = 0;

  // Only a decompression key is generated using this variant,
  // which is used for supporting key rotation.
  DecompressionOnly = 1;
}

// Configuration for the standard key type.
// Required if KeySetType is set to Standard.
message StandardKeySetConfig {
  // Computation key type.
  ComputeKeyType compute_key_type = 1;

  // The compression configuration.
  KeySetCompressionConfig keyset_compression_config = 2;
}

enum ComputeKeyType {
  // Set the compute key type to be CPU.
  // The default must be represented by 0.
  CPU = 0;
}

message KeySetAddedInfo {
  // Must be set if KeySetCompressionConfig::UseExisting is used
  RequestId compression_keyset_id = 1;

  // Must be set if KeySetType::DecompressionOnly is used
  RequestId from_keyset_id_decompression_only = 2;

  // Must be set if KeySetType::DecompressionOnly is used
  RequestId to_keyset_id_decompression_only = 3;
}

// The keyset configuration message.
// It should correspond to KeySetConfig in keyset_config.rs.
message KeySetConfig {
  // Set the keyset type.
  KeySetType keyset_type = 1;

  // Standard keyset config.
  // It must be set if KeySetType::Standard is set.
  StandardKeySetConfig standard_keyset_config = 2;
}

message KeyGenPreprocRequest {
  FheParameter params = 1;
  KeySetConfig keyset_config = 2;
  RequestId request_id = 3;
}

enum KeySetCompressionConfig {
  // The default must be represented by 0.
  Generate = 0;
  UseExisting = 1;
}

message KeyGenPreprocStatus { KeyGenPreprocStatusEnum result = 1; }

// Request for generating new keys under a certain handle and return a URI where
// they can be accessed.
message KeyGenRequest {
  // The FHE parameters for key generation. This must match
  // what was used in the preprocessing step.
  FheParameter params = 1;

  // The request ID that generated the preprocessing materials.
  RequestId preproc_id = 2;

  // The request ID of this request.
  RequestId request_id = 3;

  // The EIP712 domain used for signing the response.
  Eip712DomainMsg domain = 4;

  // The keyset configuration that controls what kind of key to generate.
  // It must match the keyset_config field in the preprocessing call with ID preproc_id.
  KeySetConfig keyset_config = 5;

  // For certain keyset_config, additional information is needed,
  // this is given by the documentation of KeySetAddedInfo.
  KeySetAddedInfo keyset_added_info = 6;
}

message KeyGenResult {
  // The ID of the key generation request
  RequestId request_id = 1;
  map<string, SignedPubDataHandle> key_results = 2;
}

// The result of generation of a public key
message SignedPubDataHandle {
  // The key handle; hash digest of the key bytes
  string key_handle = 1;
  // Signature on the key handle
  bytes signature = 2;
  // The signature on the key for the external recipient
  // (e.g. using EIP712 for the fhevm)
  bytes external_signature = 3;
}

// Keeping the fields in lowercase is important because
// it needs to match what the config reads out of the toml config files,
// e.g., in default_centralized.toml.
enum FheParameter {
  // The default must be represented by 0.
  default = 0;
  test = 1;
}

message CrsGenRequest {
  FheParameter params = 1;
  // This is the maximum number of bits that can be proven,
  // e.g. 64 for a single FheUint64 or 8 x FheUint8 values.
  // If this is not provided, then it defaults to ZK_DEFAULT_MAX_NUM_CLEARTEXT.
  optional uint32 max_num_bits = 2;
  RequestId request_id = 3;
  Eip712DomainMsg domain = 4;
}

message CrsGenResult {
  // The ID of the crs generation request
  RequestId request_id = 1;
  // The struct holding the signature and the handle of the CRS
  SignedPubDataHandle crs_results = 2;
}

message TypedCiphertext {
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  bytes ciphertext = 1;
  // The type of plaintext encrypted.
  FheType fhe_type = 2;
  // The external handle of the ciphertext (the handle used in the copro).
  bytes external_handle = 3;
}

message DecryptionRequest {
  // The one or many ciphertexts and corresponding types to decrypt
  repeated TypedCiphertext ciphertexts = 1;
  // The key id to use for decryption, will be the request_id used for key
  // generation
  RequestId key_id = 2;
  Eip712DomainMsg domain = 3;
  optional string acl_address = 4;
  // The ID of the decryption request. Will be the hash digest the other fields
  // of this message object.
  RequestId request_id = 5;
}

// The typed plaintext type, which is the result of decryption.
message TypedPlaintext {
  // The actual plaintext in bytes.
  bytes bytes = 1;
  // The type of plaintext encrypted.
  FheType fhe_type = 2;
}

// KMS-internal Decryption Response Payload, containing meta data, plaintexts
// and external results
message DecryptionResponsePayload {
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  // TODO should be renamed to make it clear it is the server's key
  bytes verification_key = 1;

  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 2;
  // A list of plaintexts, as little endian byte arrays. One for each
  // ciphertext.
  repeated TypedPlaintext plaintexts = 3;
  // the signature on external_decryption_result for the external recipient
  // (e.g. the fhevm)
  optional bytes external_signature = 4;
}

// KMS-internal Decryption Response
message DecryptionResponse {
  // Signature of the serialization of [DecryptionResponsePayload].
  bytes signature = 1;
  // The payload that is signed
  DecryptionResponsePayload payload = 2;
}

message ReencryptionRequestPayload {
  // The client's (blockchain wallet) address,
  // encoded using EIP-55.
  string client_address = 1;
  // Encoding of the user's public encryption key for this request.
  // Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
  // Montgomery point.
  bytes enc_key = 2;
  // The key id to use for decryption. Will be the request_id used during key
  // generation
  RequestId key_id = 3;
  // The list of ciphertexts to reencrypt.
  repeated TypedCiphertext typed_ciphertexts = 4;
}

// https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator
// eventually chain_id, verifying_contract and salt will be parsed in to
// solidity types
message Eip712DomainMsg {
  string name = 1;
  string version = 2;
  bytes chain_id = 3;
  string verifying_contract = 4;
  optional bytes salt = 5;
}

message ReencryptionRequest {
  // Signature of the serialization of [ReencryptionRequestPayload].
  bytes signature = 1;
  ReencryptionRequestPayload payload = 2;
  Eip712DomainMsg domain = 3;
  // The ID that identifies this request.
  // Future queries for the result must use this request ID.
  RequestId request_id = 4;
}

message ReencryptionResponse {
  bytes signature = 1;
  // Signature of the serialization of [ReencryptionResponsePayload].
  ReencryptionResponsePayload payload = 2;
}

message ReencryptionResponsePayload {
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  bytes verification_key = 1;
  // The concatenation of two digests:
  // (eip712_signing_hash(pk, domain) || ciphertext digest).
  // This is needed to ensure the response corresponds to the request.
  bytes digest = 2;
  repeated TypedSigncryptedCiphertext signcrypted_ciphertexts = 3;
  // The ID of the MPC party doing the reencryption. Used for polynomial
  // reconstruction.
  uint32 party_id = 4;
  // The degree of the sharing scheme used.
  uint32 degree = 5;
}

message TypedSigncryptedCiphertext {
  // The type of plaintext encrypted.
  FheType fhe_type = 1;
  // The signcrypted payload, using a hybrid encryption approach in
  // sign-then-encrypt.
  bytes signcrypted_ciphertext = 2;
  
  // This will be added in a later PR
  // bytes external_handle = 3;
}

message VerifyProvenCtRequest {
  RequestId crs_handle = 1;
  RequestId key_handle = 2;
  string contract_address = 3;
  string client_address = 4;
  bytes ct_bytes = 5;
  string acl_address = 6;
  Eip712DomainMsg domain = 7;
  RequestId request_id = 8;
}

// The response of an input verification request.
message VerifyProvenCtResponse {
  VerifyProvenCtResponsePayload payload = 1;
  bytes signature = 2;
}

// The response payload of an input verification request.
// This payload is signed and the signature is stored in `VerifyProvenCtResponse`.
message VerifyProvenCtResponsePayload {
  RequestId request_id = 1;
  string contract_address = 2;
  string client_address = 3;
  // The digest is a keccak256 hash of the original input ciphertext.
  bytes ct_digest = 4;
  // the signature for the external recipient (e.g. the fhevm)
  bytes external_signature = 5;
}
