use crate::algebra::structure_traits::One;
use std::ops::{Add, Mul, Sub};

use crypto_bigint::{U128, U1536, U768};
use itertools::Itertools;

use crate::experimental::algebra::levels::GenericModulus;
use crate::experimental::algebra::levels::LevelEll;
use crate::experimental::algebra::levels::LevelKsw;
use crate::experimental::algebra::levels::LevelOne;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct N65536;

pub trait Const {
    const VALUE: usize;
}

impl Const for N65536 {
    const VALUE: usize = 65536;
}

/// Trait for retrieving various constants that help in NTT.  theta is a 2Nth
/// root of unity modulo Q, hence it is different for all moduli Q (Q1, Q, QR).
/// theta^2N = 1 mod Q, theta_inv = theta^-1 mod Q, phi_inv = N^-1 mod Q.
/// These variables can be computed easily when Q is prime using
/// https://github.com/KULeuven-COSIC/SCALE-MAMBA/blob/c111516e3ebc1efd12a2bd47dd2122b160e13d1e/src/FHE/FFT_Data.cpp#L15
/// When the moduli is composite, these were generated by getting the 2Nth root
/// for each prime factor and then applied CRT to get the final root.
/// One can check easily against the constants below that theta^2N = 1 mod Q, etc.
pub trait NTTConstants<T> {
    const THETA: T;
    const THETA_INV: T;
    const PHI_INV: T;
}

impl NTTConstants<LevelOne> for N65536 {
    const THETA: LevelOne = LevelOne {
        value: GenericModulus(U128::from_be_hex("00000000216a97b99790deda2581c966")),
    };
    const THETA_INV: LevelOne = LevelOne {
        value: GenericModulus(U128::from_be_hex("0000000031a483e82665c582633b6acc")),
    };
    const PHI_INV: LevelOne = LevelOne {
        value: GenericModulus(U128::from_be_hex("000000003fffffffc0000013ffffffed")),
    };
}
impl NTTConstants<LevelEll> for N65536 {
    const THETA: LevelEll = LevelEll {value: GenericModulus(U768::from_be_hex("0000df5c1598c1b46c81750b352b06734984ccd2166734adfc8f575b3da2123bd2457d3a1f1bc534e9c7221e4ebd18d7e9b485ff0b8d49932cecd1e4b06e767e1ae6a12614bc27a24a022ef0a830ef21d9db34ccbadd5d9a22326babbb1ed6a6"))};
    const THETA_INV: LevelEll = LevelEll {value: GenericModulus(U768::from_be_hex("0000f33ce4d4ee6a4f0b2c59da8be7bf7bea3264807d764f41b66d01668537e8f34f071777b65b6eae66f3e6295a17166f93d85796f78d28b340162cb423a5a60fee16920deed8bbf9525f0393d924ebf2377f8f5ccf30132668c09b7104fb7b"))};
    const PHI_INV: LevelEll = LevelEll {value: GenericModulus(U768::from_be_hex("00012229d6e9eb1c8ae383fd39127ea7d5c7e34a74ae10d9821bbbb23eca3085a9b4c97cf375afe197582c00c8388386a165e1a54e0bcf5cf3532291f0ef1c2299cd7dba0b3b218c532c618cb287f0ecc2e4b05ac1f83be100fd294e58bcefd3"))};
}
impl NTTConstants<LevelKsw> for N65536 {
    const THETA: LevelKsw = LevelKsw {value: GenericModulus(U1536::from_be_hex("0000001bb361d7f7aca028e8e41766cad00c7045d417a2f9746391072bdfb44f28306347abe9f921b875f0002d53ff763d40af772cffe67d3bf6f98b3b0ea13d76b39ebdacc17e968e320567085824e3642d9e0b298c23cbeb24b5852ed2b99d5f3524744d8a9f0385adfcbc39f004c688f698ebb94553f262c0736fbadd0d2472417a672bb684ac4bb514f3413c1bfc6d4ad235702249f1ea32d210cd0645677a3a82555a07bc5417c41ad19262b82368988590a189e2af6982b9a75d4ee85d"))};
    const THETA_INV: LevelKsw = LevelKsw {value: GenericModulus(U1536::from_be_hex("00000019bed338b9bd8954e21667c6551795be54b7e5458caeee6de136fc6d5439dc44be4be7982ab24ef87a6320c0649ef4587efe144be5e3ccd2dc75bc660ccc50e729bcc31a1d110034d353cbc2ffbb71e2e394b2ab37616b11dd91a543947608f22f3da3973bd4e331fb9cf3f252b5f31a042b69ed6eec24acedceb660d9e8fd539e6da3e496c8c7bd5cc6a7ec045bd7cd1486662b9de6deaaa32a0112d809490086171706c310cfbb5f73a85ac2fe0f629c5b26d9c16fb9986b02d4e8b7"))};
    const PHI_INV: LevelKsw = LevelKsw {value: GenericModulus(U1536::from_be_hex("00000024455f227840cec001dc17a1f6f74a8df7224aff10b0f25ea7b9bf4f8de9fb474e66379e546ae8e7386b1e872977e49d906165f623ad185602bca27021a236be02f0f11ea598ee9716972282946e967a2e67ee4a5fbb279bc549826418a33b3cd136cad9285bdeffa2800e0fcd55503bc3a401edb929e2b0afe27163a178defef16711e570daece7f31700b4399c77b831790d2dae2b63f3ad4ff0949b29204a3156c66d1d947698d7ef9f24e3e8148dee8fdae09921b1b24d55dcefc3"))};
}

fn power<T>(base: T, exponent: usize) -> T
where
    T: One,
    T: Clone,
    T: Mul<Output = T>,
{
    if exponent == 1 {
        base
    } else if exponent == 0 {
        T::ONE
    } else {
        let mut res = T::ONE;
        let mut bt = base;
        let mut exponent = exponent;
        while exponent != 0 {
            if exponent & 1 == 1 {
                res = res.clone() * bt.clone();
            }
            exponent >>= 1;
            bt = bt.clone() * bt.clone();
        }
        res
    }
}

pub fn ntt_iter2<T>(ioutput: &mut [T], n: usize, root: T)
where
    T: One,
    T: Clone,
    T: Mul<Output = T>,
    T: Add<Output = T>,
    T: Sub<Output = T>,
{
    let mut j = 0;
    for i in 0..n {
        if j >= i {
            ioutput.swap(i, j);
        }
        let mut m = n / 2;
        while m >= 1 && j >= m {
            j -= m;
            m /= 2;
        }
        j += m;
    }

    let mut s = 1;
    while s < n {
        let m = 2 * s;
        let alpha = power(root.clone(), n / m);
        let mut alpha2 = alpha.clone();
        let alpha = alpha.clone() * alpha;
        for j in 0..m / 2 {
            let mut k = j;
            while k < n {
                let t = alpha2.clone() * ioutput[k + m / 2].clone();
                let u = ioutput[k].clone();
                ioutput[k] = u.clone() + t.clone();
                ioutput[k + m / 2] = u - t;
                k += m;
            }
            alpha2 = alpha2 * alpha.clone();
        }
        s *= 2;
    }
}

fn ntt_iter<T>(ioutput: &mut [T], n: usize, root: T)
where
    T: One,
    T: Clone,
    T: Mul<Output = T>,
    T: Add<Output = T>,
    T: Sub<Output = T>,
{
    let mut j = 0;
    for i in 0..n {
        if j >= i {
            ioutput.swap(i, j);
        }
        let mut m = n / 2;
        while m >= 1 && j >= m {
            j -= m;
            m /= 2;
        }
        j += m;
    }

    let mut s = 1;
    while s < n {
        let m = 2 * s;
        let alpha = power(root.clone(), n / m);
        let mut alpha2 = T::ONE;
        for j in 0..m / 2 {
            let mut k = j;
            while k < n {
                let t = alpha2.clone() * ioutput[k + m / 2].clone();
                let u = ioutput[k].clone();
                ioutput[k] = u.clone() + t.clone();
                ioutput[k + m / 2] = u - t;
                k += m;
            }
            alpha2 = alpha2 * alpha.clone();
        }
        s *= 2;
    }
}

pub fn ntt_inv<T, N>(ioutput: &mut [T], n: usize)
where
    T: One,
    T: Clone,
    T: Add<Output = T>,
    T: Mul<T, Output = T>,
    T: Sub<Output = T>,
    N: NTTConstants<T>,
    T: for<'a> Mul<&'a T, Output = T>,
{
    let squared_root_inv = N::THETA_INV * N::THETA_INV;
    ntt_iter(ioutput, n, squared_root_inv);
    let mut accumulator = N::PHI_INV;
    for out in ioutput.iter_mut().take(n) {
        *out = out.clone() * &accumulator;
        accumulator = accumulator * &N::THETA_INV;
    }
}

pub fn hadamard_product<L, R, O>(lhs: &[L], rhs: Vec<R>) -> Vec<O>
where
    R: for<'a> Mul<&'a L, Output = O>,
{
    lhs.iter().zip(rhs).map(|(x, y)| y * x).collect_vec()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::algebra::structure_traits::Sample;

    use crate::algebra::structure_traits::Zero;
    use aes_prng::AesRng;
    use rand::SeedableRng;

    fn naive_mul<T>(a: &[T], b: &[T], n: usize) -> Vec<T>
    where
        T: Zero + Copy,
        T: Add<Output = T>,
        T: Mul<Output = T>,
        T: Sub<Output = T>,
    {
        let mut c = Vec::with_capacity(n);
        for _ in 0..n {
            c.push(T::ZERO);
        }

        for i in 0..n {
            for j in 0..n {
                let w = c[(i + j) % n];
                if (i + j) < n {
                    c[i + j] = w + a[i] * b[j];
                } else {
                    c[(i + j) % n] = w - a[i] * b[j]
                }
            }
        }
        c
    }

    #[test]
    fn poly_q1mul() {
        let mut rng = AesRng::seed_from_u64(0);

        let mut a = Vec::with_capacity(N65536::VALUE);
        let mut b = Vec::with_capacity(N65536::VALUE);
        for _ in 0..N65536::VALUE {
            a.push(LevelOne::sample(&mut rng));
            b.push(LevelOne::sample(&mut rng));
        }
        let c = naive_mul(&a, &b, N65536::VALUE);
        ntt_iter2(&mut a, N65536::VALUE, N65536::THETA);
        ntt_iter2(&mut b, N65536::VALUE, N65536::THETA);
        let mut c_fft: Vec<LevelOne> = hadamard_product(&a, b); //a.iter().zip(b).map(|(x, y)| *x * y).collect();

        ntt_inv::<LevelOne, N65536>(&mut c_fft, N65536::VALUE);
        assert_eq!(c, c_fft);
    }

    #[test]
    fn poly_qmul() {
        let mut rng = AesRng::seed_from_u64(0);

        let mut a = Vec::with_capacity(N65536::VALUE);
        let mut b = Vec::with_capacity(N65536::VALUE);
        for _ in 0..N65536::VALUE {
            a.push(LevelEll::sample(&mut rng));
            b.push(LevelEll::sample(&mut rng));
        }
        let c = naive_mul(&a, &b, N65536::VALUE);
        ntt_iter2(&mut a, N65536::VALUE, N65536::THETA);
        ntt_iter2(&mut b, N65536::VALUE, N65536::THETA);
        let mut c_fft: Vec<LevelEll> = a.iter().zip(b).map(|(x, y)| *x * y).collect();

        ntt_inv::<LevelEll, N65536>(&mut c_fft, N65536::VALUE);
        assert_eq!(c, c_fft);
    }
}
