use std::{num::Wrapping, sync::Arc};

use ndarray::Array1;
use rand_chacha::ChaCha20Rng;
use tfhe::core_crypto::prelude::Numeric;
use tokio::{task::JoinSet, time::timeout_at};

use crate::{
    algebra::{residue_poly::ResiduePoly, residue_poly::ResiduePoly128, structure_traits::Ring},
    error::error_handler::anyhow_error_and_log,
    execution::{
        constants::INPUT_PARTY_ID,
        runtime::{
            party::Role,
            session::{
                BaseSession, BaseSessionHandles, ParameterHandles, SessionParameters, SetupMode,
                SmallSession, SmallSessionStruct, ToBaseSession,
            },
        },
        sharing::input::robust_input,
        small_execution::{agree_random::DummyAgreeRandom, prss::PRSSSetup},
    },
    lwe::{gen_key_set, KeySet, PubConKeyPair, SecretKeyShare, ThresholdLWEParameters},
    networking::value::NetworkValue,
};

pub async fn transfer_pk<Z: Ring>(
    session: &BaseSession,
    pubkey: Option<PubConKeyPair>,
    role: &Role,
    input_party_id: usize,
) -> anyhow::Result<PubConKeyPair> {
    session.network().increase_round_counter().await?;
    if role.one_based() == input_party_id {
        let pubkey_raw = pubkey
            .ok_or_else(|| anyhow_error_and_log("I have no public key to send!".to_string()))?;
        let num_parties = session.amount_of_parties();
        let pkval = NetworkValue::<Z>::PubKey(Box::new(pubkey_raw.clone()));

        let mut set = JoinSet::new();
        for to_send_role in 1..=num_parties {
            if to_send_role != input_party_id {
                let identity = session.identity_from(&Role::indexed_by_one(to_send_role))?;

                let networking = Arc::clone(session.network());
                let session_id = session.session_id();
                let send_pk = pkval.clone();

                set.spawn(async move {
                    let _ = networking
                        .send(send_pk.to_network(), &identity, &session_id)
                        .await;
                });
            }
        }
        while (set.join_next().await).is_some() {}
        Ok(pubkey_raw)
    } else {
        let receiver = session.identity_from(&Role::indexed_by_one(input_party_id))?;
        let networking = Arc::clone(session.network());
        let session_id = session.session_id();
        let timeout = session.network().get_timeout_current_round()?;
        tracing::debug!(
            "Waiting for receiving public key from input party with timeout {:?}",
            timeout
        );
        let data = tokio::spawn(timeout_at(timeout, async move {
            networking.receive(&receiver, &session_id).await
        }))
        .await??;

        let pk = match NetworkValue::<Z>::from_network(data)? {
            NetworkValue::PubKey(pk) => pk,
            _ => Err(anyhow_error_and_log(
                "I have received sth different from a public key!".to_string(),
            ))?,
        };
        Ok(*pk)
    }
}

pub async fn initialize_key_material(
    session: &mut SmallSession<ResiduePoly128>,
    setup_mode: SetupMode,
    params: ThresholdLWEParameters,
) -> anyhow::Result<(
    SecretKeyShare,
    PubConKeyPair,
    Option<PRSSSetup<ResiduePoly128>>,
)> {
    let prss_setup = if setup_mode == SetupMode::AllProtos {
        Some(
            PRSSSetup::init_with_abort::<
                DummyAgreeRandom,
                ChaCha20Rng,
                SmallSessionStruct<ResiduePoly128, ChaCha20Rng, SessionParameters>,
            >(session)
            .await?,
        )
    } else {
        None
    };

    let own_role = session.my_role()?;

    let mut keyset: Option<KeySet> = None;

    if own_role.one_based() == INPUT_PARTY_ID {
        keyset = Some(gen_key_set(params, &mut session.rng()));
        tracing::info!("Keyset generated by input party {}", own_role);
    }

    let sk_container64: Vec<u64> = keyset
        .as_ref()
        .map(|s| s.clone().sk.lwe_secret_key_64.into_container())
        .unwrap_or_else(|| {
            // TODO: This needs to be refactor, since we have done this hack in order all the
            // parties that are not INPUT_PARTY_ID wait for INPUT_PARTY_ID to generate the keyset
            // and distribute the lwe secret key vector to the rest. Otherwise if we would have set
            // Vec::new() here, the other parties would have continued to transfer_pk and would
            // have panicked because they would have received something different from a PK.
            vec![Numeric::ZERO; params.input_cipher_parameters.lwe_dimension.0]
        });

    let sk_container128: Vec<u128> = keyset
        .as_ref()
        .map(|s| s.clone().sk.lwe_secret_key_128.into_container())
        .unwrap_or_else(|| {
            // TODO: This needs to be refactor, since we have done this hack in order all the
            // parties that are not INPUT_PARTY_ID wait for INPUT_PARTY_ID to generate the keyset
            // and distribute the lwe secret key vector to the rest. Otherwise if we would have set
            // Vec::new() here, the other parties would have continued to transfer_pk and would
            // have panicked because they would have received something different from a PK.
            vec![
                Numeric::ZERO;
                params.output_cipher_parameters.polynomial_size.0
                    * params.output_cipher_parameters.glwe_dimension.0
            ]
        });

    // iterate through sk and share each element

    let mut key_shares64 = Vec::new();
    // iterate through sk and share each element
    // TODO(Dragos) this sharing can be done in a single round
    tracing::info!("Sharing key64 to be send {}", sk_container64.len());
    for cur in sk_container64 {
        let secret = match own_role.one_based() {
            1 => Some(ResiduePoly::from_scalar(Wrapping::<u64>(cur))),
            _ => None,
        };
        let share = robust_input::<_, ChaCha20Rng>(
            &mut session.to_base_session(),
            &secret,
            &own_role,
            INPUT_PARTY_ID,
        )
        .await?; //TODO(Daniel) batch this for all big_ell

        key_shares64.push(share);
    }

    let mut key_shares128 = Vec::new();
    // TODO(Dragos) this sharing can be done in a single round
    tracing::info!("Sharing key128 to be send {}", sk_container128.len());
    for cur in sk_container128 {
        let secret = match own_role.one_based() {
            1 => Some(ResiduePoly::from_scalar(Wrapping::<u128>(cur))),
            _ => None,
        };
        let share = robust_input::<_, ChaCha20Rng>(
            &mut session.to_base_session(),
            &secret,
            &own_role,
            INPUT_PARTY_ID,
        )
        .await?; //TODO(Daniel) batch this for all big_ell

        key_shares128.push(share);
    }

    let pubcon = keyset.map(|s| PubConKeyPair { pk: s.pk, ck: s.ck });
    let transferred_pk = transfer_pk::<ResiduePoly128>(
        &session.to_base_session(),
        pubcon,
        &own_role,
        INPUT_PARTY_ID,
    )
    .await?;

    let shared_sk = SecretKeyShare {
        input_key_share64: Array1::from_vec(key_shares64),
        input_key_share128: Array1::from_vec(key_shares128),
        threshold_lwe_parameters: params,
    };

    Ok((shared_sk, transferred_pk, prss_setup))
}
