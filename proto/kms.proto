syntax = "proto3";
package kms;

service KmsEndpoint {
  rpc Decrypt(DecryptionRequest) returns (DecryptionResponse);
  rpc Reencrypt(ReencryptionRequest) returns (ReencryptionResponse);
}

enum FheType {
  Bool = 0;
  Euint8 = 1;
  Euint16 = 2;
  Euint32 = 3;
}

message Proof {
  uint32 height = 1;
  bytes merkle_patricia_proof = 2;
}

message DecryptionRequestPayload {
  uint32 shares_needed = 1;
  bytes verification_key = 2;
  FheType fhe_type = 3;
  bytes ciphertext = 4;
  Proof proof = 5;
  bytes randomness = 6;
}

message DecryptionRequest {
  bytes signature = 1;
  DecryptionRequestPayload payload = 2;
}

// TODO shares_needed are not really needed since there is a link to the digest, however, it seems better to be able to handle a response without getting data from the request as well.
// but this is also a security issue since it is possible to get meaning from the response without directly linking it to a request
message DecryptionResponsePayload {
  uint32 shares_needed = 1;
  bytes verification_key = 2;
  bytes plaintext = 3;
  bytes digest = 4;
  bytes randomness = 5;
}

message DecryptionResponse {
  bytes signature = 1;
  DecryptionResponsePayload payload = 2;
}

message AggregatedDecryptionResponse {
  repeated DecryptionResponse responses = 1;
}

message ReencryptionRequestPayload {
  uint32 shares_needed = 1;
  bytes verification_key = 2;
  bytes enc_key = 3;
  FheType fhe_type = 4;
  bytes ciphertext = 5;
  Proof proof = 6;
  bytes randomness = 7;
  }

message ReencryptionRequest {
  bytes signature = 1;
  ReencryptionRequestPayload payload = 2;
}

message ReencryptionResponse {
  uint32 shares_needed = 1;
  bytes verification_key = 2;
  FheType fhe_type = 3;
  bytes signcrypted_ciphertext = 4;
  bytes digest = 5;
}

message AggregatedReencryptionResponse {
  map<uint32, ReencryptionResponse> responses = 1;
}
