syntax = "proto3";
package kms;

service KmsEndpoint {
  rpc Decrypt(DecryptionRequest) returns (DecryptionResponse);
  rpc Reencrypt(ReencryptionRequest) returns (ReencryptionResponse);
}

// The plaintext types that can be encrypted in a fhevm ciphertext.
enum FheType {
  Bool = 0;
  Euint4 = 1;
  Euint8 = 2;
  Euint16 = 3;
  Euint32 = 4;
  Euint64 = 5;
}

message DecryptionRequest {
  // Version of the request format.
  uint32 version = 1;
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  // Needed to avoid a single malicious server taking over a request that should
  // have been distributed.
  uint32 shares_needed = 2;
  // The type of plaintext encrypted.
  FheType fhe_type = 3;
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  bytes ciphertext = 4;
  // Randomness added to the request.
  // Required to ensure formal EU-CMA security when using ECDSA.
  bytes randomness = 5;
}

message DecryptionResponsePayload {
  // Version of the response format.
  uint32 version = 1;
  // TODO shares_needed are not really needed since there is a link to the
  // digest, however, it seems better to be able to handle a response without
  // getting data from the request as well. but this is also a security issue
  // since it is possible to get meaning from the response without directly
  // linking it to a request
  //
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  uint32 shares_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  bytes verification_key = 3;
  // Little endian encoding of the plaintext.
  bytes plaintext = 4;
  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 5;
  // Randomness specified in the request to ensure EU-CMA of the signed
  // response.
  // TODO check that we don't need two types of randomness. One for the reuqest
  // and one for the response
  bytes randomness = 6;
}

message DecryptionResponse {
  bytes signature = 1;
  // Signature of the ASN1 DER serialization of [DecryptionResponsePayload].
  DecryptionResponsePayload payload = 2;
}

message AggregatedDecryptionResponse {
  repeated DecryptionResponse responses = 1;
}

message ReencryptionRequestPayload {
  // Version of the request format.
  uint32 version = 1;
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  // Needed to avoid a single malicious server taking over a request that should
  // have been distributed.
  uint32 shares_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  bytes verification_key = 3;
  // Encoding of the user's public encryption key for this request.
  // Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
  // Montgomery point.
  bytes enc_key = 4;
  // The type of plaintext encrypted.
  FheType fhe_type = 5;
  // The actual ciphertext to decrypt, taken directly from the fhevm.
  bytes ciphertext = 6;
  // Randomness specified in the request to ensure EU-CMA of the signed
  // response.
  // TODO check that we don't need two types of randomness. One for the reuqest
  // and one for the response
  bytes randomness = 7;
}

message ReencryptionRequest {
  bytes signature = 1;
  // Signature of the ASN1 DER serialization of [DecryptionResponsePayload].
  ReencryptionRequestPayload payload = 2;
}

message ReencryptionResponse {
  // Version of the response format.
  uint32 version = 1;
  // TODO shares_needed are not really needed since there is a link to the
  // digest, however, it seems better to be able to handle a response without
  // getting data from the request as well. but this is also a security issue
  // since it is possible to get meaning from the response without directly
  // linking it to a request
  //
  // The amount of shares needed to recombine the result.
  // This implies the threshold used.
  uint32 shares_needed = 2;
  // The server's signature verification key.
  // Encoded using SEC1.
  // Needed to validate the response, but MUST also be linked to a list of
  // trusted keys.
  bytes verification_key = 3;
  // The type of plaintext encrypted.
  FheType fhe_type = 4;
  // The signcrypted payload, using a hybrid encryption approach in
  // sign-then-encrypt.
  bytes signcrypted_ciphertext = 5;
  // Digest of the request validated.
  // Needed to ensure that the response is for the expected request.
  bytes digest = 6;
}

message AggregatedReencryptionResponse {
  map<uint32, ReencryptionResponse> responses = 1;
}
